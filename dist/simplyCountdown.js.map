{"version":3,"file":"simplyCountdown.js","sources":["../src/core/dom.ts","../src/core/simplyCountdown.ts"],"sourcesContent":["/**\n * Creates a countdown section element\n */\nexport const createCountdownSection = (\n    sectionClass: string,\n    amountClass: string,\n    wordClass: string,\n    amount: number,\n    word: string,\n    params: {\n        sectionClass: string;\n        amountClass: string;\n        wordClass: string;\n    }\n): HTMLElement => {\n    const section = document.createElement('div');\n    section.className = `${sectionClass} ${params.sectionClass}`;\n\n    const wrap = document.createElement('div');\n    const amount_elem = document.createElement('span');\n    const word_elem = document.createElement('span');\n\n    amount_elem.className = `${amountClass} ${params.amountClass}`;\n    word_elem.className = `${wordClass} ${params.wordClass}`;\n\n    amount_elem.textContent = String(amount);\n    word_elem.textContent = word;\n\n    wrap.appendChild(amount_elem);\n    wrap.appendChild(word_elem);\n    section.appendChild(wrap);\n\n    return section;\n};\n\n/**\n * Retrieves a countdown section element from a container\n */\nexport const getCountdownSection = (\n    sectionClass: string,\n    container: HTMLElement\n): HTMLElement | null => {\n    return container.querySelector(`.simply-section.${sectionClass}`);\n};\n\n/**\n * Updates a countdown section element\n */\nexport const updateCountdownSection = (\n    section: HTMLElement,\n    amount: number | string,\n    word: string\n): void => {\n    const amountElement = section.querySelector('.simply-amount');\n    const wordElement = section.querySelector('.simply-word');\n\n    if (amountElement) {\n        amountElement.textContent = String(amount);\n    }\n    if (wordElement) {\n        wordElement.textContent = word;\n    }\n};\n\n/**\n * Creates all countdown elements\n */\nexport const createCountdown = (\n    container: HTMLElement,\n    params: {\n        sectionClass: string;\n        amountClass: string;\n        wordClass: string;\n    }\n): {\n    days: HTMLElement;\n    hours: HTMLElement;\n    minutes: HTMLElement;\n    seconds: HTMLElement;\n} => {\n\n    const amountCls = 'simply-amount';\n    const wordCls = 'simply-word';\n    \n    const days = createCountdownSection('simply-section simply-days-section', amountCls, wordCls, 0, 'day', params);\n    const hours = createCountdownSection('simply-section simply-hours-section', amountCls, wordCls, 0, 'hour', params);\n    const minutes = createCountdownSection('simply-section simply-minutes-section', amountCls, wordCls, 0, 'minute', params);\n    const seconds = createCountdownSection('simply-section simply-seconds-section', amountCls, wordCls, 0, 'second', params);\n\n    container.appendChild(days);\n    container.appendChild(hours);\n    container.appendChild(minutes);\n    container.appendChild(seconds);\n\n    return {\n        days,\n        hours,\n        minutes,\n        seconds\n    };\n};\n","/*!\n * Project : simplyCountdown\n * Date : 2024-12-24\n * License : MIT\n * Version : 3.0.0\n * Author : Vincent Loy-Serre <vincent.loy1@gmail.com>\n * Contributors :\n *  - Justin Beasley <JustinB@harvest.org>\n *  - Nathan Smith <NathanS@harvest.org>\n */\n\nimport type { CountdownParameters, CountdownSelector, CountdownState, CountdownController, CountdownControllerArray } from '../types';\nimport { createCountdown, updateCountdownSection } from './dom';\n\nconst defaultParams: CountdownParameters = {\n    year: 2024,\n    month: 12,\n    day: 25,\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n    words: {\n        days: { lambda: (root, n) => n > 1 ? root + 's' : root, root: 'day' },\n        hours: { lambda: (root, n) => n > 1 ? root + 's' : root, root: 'hour' },\n        minutes: { lambda: (root, n) => n > 1 ? root + 's' : root, root: 'minute' },\n        seconds: { lambda: (root, n) => n > 1 ? root + 's' : root, root: 'second' }\n    },\n    plural: true,\n    inline: false,\n    inlineSeparator: ', ',\n    enableUtc: false,\n    onEnd: () => {},\n    refresh: 1000,\n    inlineClass: 'simply-countdown-inline',\n    sectionClass: 'simply-section',\n    amountClass: 'simply-amount',\n    wordClass: 'simply-word',\n    zeroPad: false,\n    countUp: false,\n    removeZeroUnits: false,\n    onStop: () => {},\n    onResume: () => {},\n    onUpdate: () => {},\n};\n\nconst isNodeList = (element: CountdownSelector): element is NodeListOf<HTMLElement> => {\n    return element instanceof NodeList;\n};\n\ninterface TimeUnit {\n    value: number;\n    word: keyof CountdownParameters['words'];\n    element?: HTMLElement;\n}\n\n/**\n * Formats a time unit with optional zero padding and pluralization\n * @param unit - The time unit object containing value and word properties\n * @param params - The countdown parameters containing formatting options and word definitions\n * @returns A formatted string containing the value and pluralized word for the time unit\n * @example\n * // With zeroPad: true\n * formatTimeUnit({value: 5, word: 'days'}, params) // returns \"05 days\"\n * // With zeroPad: false\n * formatTimeUnit({value: 5, word: 'days'}, params) // returns \"5 days\"\n */\nfunction formatTimeUnit(unit: TimeUnit, params: CountdownParameters): string {\n    const value = params.zeroPad ? String(unit.value).padStart(2, '0') : unit.value;\n    return `${value} ${params.words[unit.word].lambda(params.words[unit.word].root, unit.value)}`;\n}\n\n/**\n * Determines whether a time unit should be displayed based on its value and the values of previous units\n * @param unit - The current time unit to evaluate\n * @param previousUnits - Array of time units that come before the current unit\n * @param params - Configuration parameters for the countdown\n * @returns True if the unit should be displayed, false otherwise\n * \n * If removeZeroUnits is false in params, always returns true.\n * Otherwise, returns true if either:\n * - The current unit value is not zero\n * - Any previous unit has a non-zero value\n */\nfunction shouldDisplay(unit: TimeUnit, previousUnits: TimeUnit[], params: CountdownParameters): boolean {\n    if (!params.removeZeroUnits) return true;\n    return unit.value !== 0 || previousUnits.some(u => u.value !== 0);\n}\n\n/**\n * Displays the countdown timer inline within the specified HTML element.\n * \n * @param timeUnits - Array of time units containing values and labels for display\n * @param params - Configuration parameters for the countdown display\n * @param element - The HTML element where the countdown will be rendered\n * \n * @remarks\n * The function filters and formats time units based on display rules, then joins them with\n * the specified separator from params.inlineSeparator before setting the element's innerHTML.\n */\nfunction displayInline(timeUnits: TimeUnit[], params: CountdownParameters, element: HTMLElement): void {\n    const displayStr = timeUnits\n        .filter((unit, index) => shouldDisplay(unit, timeUnits.slice(0, index), params))\n        .map(unit => formatTimeUnit(unit as { value: number; word: keyof typeof params.words }, params))\n        .join(params.inlineSeparator);\n\n    element.innerHTML = displayStr;\n}\n\n/**\n * Updates the display of time units in the countdown based on their values and display conditions\n * @param timeUnits - Array of TimeUnit objects containing the time values and their corresponding words\n * @param params - Configuration parameters for the countdown display\n * @param countdown - DOM elements representing the countdown display sections\n * @returns void\n *\n * @remarks\n * This function iterates through each time unit and determines whether it should be shown based on:\n * - If it's the seconds unit (always shown)\n * - If it meets display criteria based on previous units\n * \n * For units that should be shown, it:\n * - Updates the display value (with optional zero padding)\n * - Updates the word label using the configured lambda function\n * - Shows the unit's DOM element\n * \n * For units that shouldn't be shown, it hides their DOM elements\n */\nfunction displayBlocks(timeUnits: TimeUnit[], params: CountdownParameters, countdown: any): void {\n    timeUnits.forEach((unit, index) => {\n        const shouldShow = unit.word === 'seconds' || shouldDisplay(unit, timeUnits.slice(0, index), params);\n        \n        if (shouldShow) {\n            updateCountdownSection(\n                countdown[unit.word],\n                params.zeroPad ? String(unit.value).padStart(2, '0') : unit.value,\n                params.words[unit.word].lambda(params.words[unit.word].root, unit.value)\n            );\n            countdown[unit.word].style.display = '';\n        } else {\n            countdown[unit.word].style.display = 'none';\n        }\n    });\n}\n\n/**\n * Creates a countdown instance that manages the countdown timer functionality.\n * \n * @param targetElement - The HTML element where the countdown will be rendered\n * @param parameters - Configuration parameters for the countdown\n * \n * @returns A controller object with methods to control the countdown:\n *  - stopCountdown: Pauses the countdown and triggers onStop callback\n *  - resumeCountdown: Resumes a paused countdown and triggers onResume callback\n *  - updateCountdown: Updates countdown parameters and triggers onUpdate callback\n *  - getState: Returns current state of the countdown\n */\nconst createCountdownInstance = (\n    targetElement: HTMLElement, \n    parameters: CountdownParameters\n): CountdownController => {\n    let state: CountdownState = {\n        isPaused: false,\n        interval: null,\n        targetDate: new Date()\n    };\n\n    const getTargetDate = (params: CountdownParameters): Date => {\n        return params.enableUtc \n            ? new Date(Date.UTC(\n                params.year,\n                params.month - 1,\n                params.day,\n                params.hours,\n                params.minutes,\n                params.seconds\n            ))\n            : new Date(\n                params.year,\n                params.month - 1,\n                params.day,\n                params.hours,\n                params.minutes,\n                params.seconds\n            );\n    };\n\n    state.targetDate = getTargetDate(parameters);\n\n    // Create span element for inline mode\n    let inlineElement: HTMLElement | null = null;\n    if (parameters.inline) {\n        inlineElement = document.createElement('span');\n        inlineElement.className = parameters.inlineClass;\n        targetElement.appendChild(inlineElement);\n    }\n\n    const countdown = parameters.inline ? null : createCountdown(targetElement, {\n        sectionClass: parameters.sectionClass,\n        amountClass: parameters.amountClass,\n        wordClass: parameters.wordClass\n    });\n\n    const refresh = () => {\n        // Fix UTC current date handling\n        const currentDate = parameters.enableUtc \n            ? new Date(Date.UTC(\n                new Date().getUTCFullYear(),\n                new Date().getUTCMonth(),\n                new Date().getUTCDate(),\n                new Date().getUTCHours(),\n                new Date().getUTCMinutes(),\n                new Date().getUTCSeconds()\n            ))\n            : new Date();\n\n        let diff = parameters.countUp\n            ? currentDate.getTime() - state.targetDate.getTime()\n            : state.targetDate.getTime() - currentDate.getTime();\n\n        if (diff <= 0 && !parameters.countUp) {\n            diff = 0;\n            // Clear interval before calling onEnd to prevent multiple calls\n            if (state.interval !== null) {\n                clearInterval(state.interval);\n            }\n            \n            if (parameters.onEnd) {\n                parameters.onEnd();\n            }\n        }\n\n        const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n        diff -= days * 1000 * 60 * 60 * 24;\n\n        const hours = Math.floor(diff / (1000 * 60 * 60));\n        diff -= hours * 1000 * 60 * 60;\n\n        const minutes = Math.floor(diff / (1000 * 60));\n        diff -= minutes * 1000 * 60;\n\n        const seconds = Math.floor(diff / 1000);\n\n        if (parameters.inline && inlineElement) {\n            const timeUnits: TimeUnit[] = [\n                { value: days, word: 'days' as keyof CountdownParameters['words'] },\n                { value: hours, word: 'hours' as keyof CountdownParameters['words'] },\n                { value: minutes, word: 'minutes' as keyof CountdownParameters['words'] },\n                { value: seconds, word: 'seconds' as keyof CountdownParameters['words'] }\n            ];\n            displayInline(timeUnits, parameters, inlineElement);\n        } else if (countdown) {\n            const timeUnits: TimeUnit[] = [\n                { value: days, word: 'days' as keyof CountdownParameters['words'] },\n                { value: hours, word: 'hours' as keyof CountdownParameters['words'] },\n                { value: minutes, word: 'minutes' as keyof CountdownParameters['words'] },\n                { value: seconds, word: 'seconds' as keyof CountdownParameters['words'] }\n            ];\n            displayBlocks(timeUnits, parameters, countdown);\n        }\n    };\n\n    const startInterval = () => {\n        state.interval = setInterval(refresh, parameters.refresh);\n        refresh();\n    };\n\n    const stopCountdown = () => {\n        if (state.interval !== null) {\n            clearInterval(state.interval);\n            state.interval = null;\n        }\n        state.isPaused = true;\n        parameters.onStop?.();\n    };\n\n    const resumeCountdown = () => {\n        if (state.isPaused) {\n            startInterval();\n            state.isPaused = false;\n            parameters.onResume?.();\n        }\n    };\n\n    const updateCountdown = (newParams: Partial<CountdownParameters>) => {\n        Object.assign(parameters, newParams);\n        if (newParams.year !== undefined || \n            newParams.month !== undefined || \n            newParams.day !== undefined ||\n            newParams.hours !== undefined ||\n            newParams.minutes !== undefined ||\n            newParams.seconds !== undefined) {\n            state.targetDate = getTargetDate(parameters);\n        }\n        \n        parameters.onUpdate?.(newParams);\n        \n        if (!state.isPaused) {\n            if (state.interval) {\n                clearInterval(state.interval);\n            }\n            startInterval();\n        }\n    };\n\n    const getState = () => ({ ...state });\n\n    // Start the countdown\n    startInterval();\n\n    // Cleanup on element removal\n    const observer = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n            mutation.removedNodes.forEach((node) => {\n                if (node === targetElement) {\n                    if (state.interval !== null) {\n                        clearInterval(state.interval);\n                    }\n                    observer.disconnect();\n                }\n            });\n        });\n    });\n\n    if (targetElement.parentNode) {\n        observer.observe(targetElement.parentNode, { childList: true });\n    }\n\n    // Return controller object\n    return {\n        stopCountdown,\n        resumeCountdown,\n        updateCountdown,\n        getState\n    };\n};\n\n/**\n * Creates an enhanced array of countdown controllers with additional control methods.\n * \n * @param controllers - Array of individual countdown controllers to be combined\n * @returns An array of controllers enhanced with collective control methods:\n *  - `stopCountdown()`: Stops all countdowns in the array\n *  - `resumeCountdown()`: Resumes all countdowns in the array\n *  - `updateCountdown(newParams)`: Updates all countdowns with new parameters\n *  - `getState()`: Returns an array of states from all countdowns\n */\nconst createControllerArray = (controllers: CountdownController[]): CountdownControllerArray => {\n    const array = controllers as CountdownControllerArray;\n    \n    array.stopCountdown = () => controllers.forEach(c => c.stopCountdown());\n    array.resumeCountdown = () => controllers.forEach(c => c.resumeCountdown());\n    array.updateCountdown = (newParams) => controllers.forEach(c => c.updateCountdown(newParams));\n    array.getState = () => controllers.map(c => c.getState());\n    \n    return array;\n};\n\n/**\n * Creates a countdown timer on specified HTML elements\n * @param element - A CSS selector string, HTMLElement, or NodeList targeting the countdown container(s)\n * @param args - Optional configuration parameters for the countdown\n * @returns A CountdownController for single element or CountdownControllerArray for multiple elements\n */\nconst simplyCountdown = (\n    element: CountdownSelector,\n    args: Partial<CountdownParameters> = defaultParams\n): CountdownController | CountdownControllerArray => {\n    const parameters: CountdownParameters = { ...defaultParams, ...args };\n\n    if (typeof element === 'string') {\n        const elements = document.querySelectorAll<HTMLElement>(element);\n        const controllers = Array.from(elements).map(el => createCountdownInstance(el, parameters));\n        return controllers.length === 1 ? controllers[0] : createControllerArray(controllers);\n    }\n    \n    if (isNodeList(element)) {\n        const controllers = Array.from(element).map(el => createCountdownInstance(el, parameters));\n        return controllers.length === 1 ? controllers[0] : createControllerArray(controllers);\n    }\n    \n    return createCountdownInstance(element, parameters);\n};\n\nexport default simplyCountdown;\n"],"names":[],"mappings":"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"}