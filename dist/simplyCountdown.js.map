{"version":3,"file":"simplyCountdown.js","sources":["../src/core/dom.ts","../src/core/simplyCountdown.ts"],"sourcesContent":["/**\n * Creates a countdown section element\n */\nexport const createCountdownSection = (\n    sectionClass: string,\n    amountClass: string,\n    wordClass: string,\n    amount: number,\n    word: string,\n    params: {\n        sectionClass: string;\n        amountClass: string;\n        wordClass: string;\n    }\n): HTMLElement => {\n    const section = document.createElement(\"div\");\n    section.className = `${sectionClass} ${params.sectionClass}`;\n\n    const wrap = document.createElement(\"div\");\n    const amount_elem = document.createElement(\"span\");\n    const word_elem = document.createElement(\"span\");\n\n    amount_elem.className = `${amountClass} ${params.amountClass}`;\n    word_elem.className = `${wordClass} ${params.wordClass}`;\n\n    amount_elem.textContent = String(amount);\n    word_elem.textContent = word;\n\n    wrap.appendChild(amount_elem);\n    wrap.appendChild(word_elem);\n    section.appendChild(wrap);\n\n    return section;\n};\n\n/**\n * Retrieves a countdown section element from a container\n */\nexport const getCountdownSection = (sectionClass: string, container: HTMLElement): HTMLElement | null => {\n    return container.querySelector(`.simply-section.${sectionClass}`);\n};\n\n/**\n * Updates a countdown section element\n */\nexport const updateCountdownSection = (section: HTMLElement, amount: number | string, word: string): void => {\n    const amountElement = section.querySelector(\".simply-amount\");\n    const wordElement = section.querySelector(\".simply-word\");\n\n    if (amountElement) {\n        amountElement.textContent = String(amount);\n    }\n    if (wordElement) {\n        wordElement.textContent = word;\n    }\n};\n\n/**\n * Creates all countdown elements\n */\nexport const createCountdown = (\n    container: HTMLElement,\n    params: {\n        sectionClass: string;\n        amountClass: string;\n        wordClass: string;\n    }\n): {\n    days: HTMLElement;\n    hours: HTMLElement;\n    minutes: HTMLElement;\n    seconds: HTMLElement;\n} => {\n    const amountCls = \"simply-amount\";\n    const wordCls = \"simply-word\";\n\n    const days = createCountdownSection(\"simply-section simply-days-section\", amountCls, wordCls, 0, \"day\", params);\n    const hours = createCountdownSection(\"simply-section simply-hours-section\", amountCls, wordCls, 0, \"hour\", params);\n    const minutes = createCountdownSection(\"simply-section simply-minutes-section\", amountCls, wordCls, 0, \"minute\", params);\n    const seconds = createCountdownSection(\"simply-section simply-seconds-section\", amountCls, wordCls, 0, \"second\", params);\n\n    container.appendChild(days);\n    container.appendChild(hours);\n    container.appendChild(minutes);\n    container.appendChild(seconds);\n\n    return {\n        days,\n        hours,\n        minutes,\n        seconds,\n    };\n};\n","/*!\n * Project : simplyCountdown.js\n * Date : __SCD_BUILD_DATE__\n * License : MIT\n * Version : __SCD_VERSION__\n * Author : Vincent Loy-Serre\n * Contributors :\n *  - Justin Beasley\n *  - Nathan Smith\n *  - Mehdi Rezaei\n *  - mira01\n */\n\nimport type { CountdownParameters, CountdownSelector, CountdownState, CountdownController, CountdownControllerArray } from \"../types\";\nimport { createCountdown, updateCountdownSection } from \"./dom\";\n\nconst defaultParams: CountdownParameters = {\n    year: 2024,\n    month: 12,\n    day: 25,\n    hours: 0,\n    minutes: 0,\n    seconds: 0,\n    words: {\n        days: { lambda: (root, n) => (n > 1 ? root + \"s\" : root), root: \"day\" },\n        hours: { lambda: (root, n) => (n > 1 ? root + \"s\" : root), root: \"hour\" },\n        minutes: { lambda: (root, n) => (n > 1 ? root + \"s\" : root), root: \"minute\" },\n        seconds: { lambda: (root, n) => (n > 1 ? root + \"s\" : root), root: \"second\" },\n    },\n    plural: true,\n    inline: false,\n    inlineSeparator: \", \",\n    enableUtc: false,\n    onEnd: () => {},\n    refresh: 1000,\n    inlineClass: \"simply-countdown-inline\",\n    sectionClass: \"simply-section\",\n    amountClass: \"simply-amount\",\n    wordClass: \"simply-word\",\n    zeroPad: false,\n    countUp: false,\n    removeZeroUnits: false,\n    onStop: () => {},\n    onResume: () => {},\n    onUpdate: () => {},\n};\n\nconst isNodeList = (element: CountdownSelector): element is NodeListOf<HTMLElement> => {\n    return element instanceof NodeList;\n};\n\ninterface TimeUnit {\n    value: number;\n    word: keyof CountdownParameters[\"words\"];\n    element?: HTMLElement;\n}\n\n/**\n * Formats a time unit with optional zero padding and pluralization\n * @param unit - The time unit object containing value and word properties\n * @param params - The countdown parameters containing formatting options and word definitions\n * @returns A formatted string containing the value and pluralized word for the time unit\n * @example\n * // With zeroPad: true\n * formatTimeUnit({value: 5, word: 'days'}, params) // returns \"05 days\"\n * // With zeroPad: false\n * formatTimeUnit({value: 5, word: 'days'}, params) // returns \"5 days\"\n */\nfunction formatTimeUnit(unit: TimeUnit, params: CountdownParameters): string {\n    const value = params.zeroPad ? String(unit.value).padStart(2, \"0\") : unit.value;\n    return `${value} ${params.words[unit.word].lambda(params.words[unit.word].root, unit.value)}`;\n}\n\n/**\n * Determines whether a time unit should be displayed based on its value and the values of previous units\n * @param unit - The current time unit to evaluate\n * @param previousUnits - Array of time units that come before the current unit\n * @param params - Configuration parameters for the countdown\n * @returns True if the unit should be displayed, false otherwise\n *\n * If removeZeroUnits is false in params, always returns true.\n * Otherwise, returns true if either:\n * - The current unit value is not zero\n * - Any previous unit has a non-zero value\n */\nfunction shouldDisplay(unit: TimeUnit, previousUnits: TimeUnit[], params: CountdownParameters): boolean {\n    if (!params.removeZeroUnits) return true;\n    return unit.value !== 0 || previousUnits.some((u) => u.value !== 0);\n}\n\n/**\n * Displays the countdown timer inline within the specified HTML element.\n *\n * @param timeUnits - Array of time units containing values and labels for display\n * @param params - Configuration parameters for the countdown display\n * @param element - The HTML element where the countdown will be rendered\n *\n * @remarks\n * The function filters and formats time units based on display rules, then joins them with\n * the specified separator from params.inlineSeparator before setting the element's innerHTML.\n */\nfunction displayInline(timeUnits: TimeUnit[], params: CountdownParameters, element: HTMLElement): void {\n    const displayStr = timeUnits\n        .filter((unit, index) => shouldDisplay(unit, timeUnits.slice(0, index), params))\n        .map((unit) => formatTimeUnit(unit as { value: number; word: keyof typeof params.words }, params))\n        .join(params.inlineSeparator);\n\n    element.innerHTML = displayStr;\n}\n\n/**\n * Updates the display of time units in the countdown based on their values and display conditions\n * @param timeUnits - Array of TimeUnit objects containing the time values and their corresponding words\n * @param params - Configuration parameters for the countdown display\n * @param countdown - DOM elements representing the countdown display sections\n * @returns void\n *\n * @remarks\n * This function iterates through each time unit and determines whether it should be shown based on:\n * - If it's the seconds unit (always shown)\n * - If it meets display criteria based on previous units\n *\n * For units that should be shown, it:\n * - Updates the display value (with optional zero padding)\n * - Updates the word label using the configured lambda function\n * - Shows the unit's DOM element\n *\n * For units that shouldn't be shown, it hides their DOM elements\n */\nfunction displayBlocks(timeUnits: TimeUnit[], params: CountdownParameters, countdown: any): void {\n    timeUnits.forEach((unit, index) => {\n        const shouldShow = unit.word === \"seconds\" || shouldDisplay(unit, timeUnits.slice(0, index), params);\n\n        if (shouldShow) {\n            updateCountdownSection(\n                countdown[unit.word],\n                params.zeroPad ? String(unit.value).padStart(2, \"0\") : unit.value,\n                params.words[unit.word].lambda(params.words[unit.word].root, unit.value)\n            );\n            countdown[unit.word].style.display = \"\";\n        } else {\n            countdown[unit.word].style.display = \"none\";\n        }\n    });\n}\n\n/**\n * Creates a countdown instance that manages the countdown timer functionality.\n *\n * @param targetElement - The HTML element where the countdown will be rendered\n * @param parameters - Configuration parameters for the countdown\n *\n * @returns A controller object with methods to control the countdown:\n *  - stopCountdown: Pauses the countdown and triggers onStop callback\n *  - resumeCountdown: Resumes a paused countdown and triggers onResume callback\n *  - updateCountdown: Updates countdown parameters and triggers onUpdate callback\n *  - getState: Returns current state of the countdown\n */\nconst createCountdownInstance = (targetElement: HTMLElement, parameters: CountdownParameters): CountdownController => {\n    let state: CountdownState = {\n        isPaused: false,\n        interval: null,\n        targetDate: new Date(),\n    };\n\n    const getTargetDate = (params: CountdownParameters): Date => {\n        return params.enableUtc\n            ? new Date(Date.UTC(params.year, params.month - 1, params.day, params.hours, params.minutes, params.seconds))\n            : new Date(params.year, params.month - 1, params.day, params.hours, params.minutes, params.seconds);\n    };\n\n    state.targetDate = getTargetDate(parameters);\n\n    // Create span element for inline mode\n    let inlineElement: HTMLElement | null = null;\n    if (parameters.inline) {\n        inlineElement = document.createElement(\"span\");\n        inlineElement.className = parameters.inlineClass;\n        targetElement.appendChild(inlineElement);\n    }\n\n    const countdown = parameters.inline\n        ? null\n        : createCountdown(targetElement, {\n              sectionClass: parameters.sectionClass,\n              amountClass: parameters.amountClass,\n              wordClass: parameters.wordClass,\n          });\n\n    const refresh = () => {\n        // Fix UTC current date handling\n        const currentDate = parameters.enableUtc\n            ? new Date(\n                  Date.UTC(\n                      new Date().getUTCFullYear(),\n                      new Date().getUTCMonth(),\n                      new Date().getUTCDate(),\n                      new Date().getUTCHours(),\n                      new Date().getUTCMinutes(),\n                      new Date().getUTCSeconds()\n                  )\n              )\n            : new Date();\n\n        let diff = parameters.countUp ? currentDate.getTime() - state.targetDate.getTime() : state.targetDate.getTime() - currentDate.getTime();\n\n        if (diff <= 0 && !parameters.countUp) {\n            diff = 0;\n            // Clear interval before calling onEnd to prevent multiple calls\n            if (state.interval !== null) {\n                clearInterval(state.interval);\n            }\n\n            if (parameters.onEnd) {\n                parameters.onEnd();\n            }\n        }\n\n        const days = Math.floor(diff / (1000 * 60 * 60 * 24));\n        diff -= days * 1000 * 60 * 60 * 24;\n\n        const hours = Math.floor(diff / (1000 * 60 * 60));\n        diff -= hours * 1000 * 60 * 60;\n\n        const minutes = Math.floor(diff / (1000 * 60));\n        diff -= minutes * 1000 * 60;\n\n        const seconds = Math.floor(diff / 1000);\n\n        if (parameters.inline && inlineElement) {\n            const timeUnits: TimeUnit[] = [\n                { value: days, word: \"days\" as keyof CountdownParameters[\"words\"] },\n                {\n                    value: hours,\n                    word: \"hours\" as keyof CountdownParameters[\"words\"],\n                },\n                {\n                    value: minutes,\n                    word: \"minutes\" as keyof CountdownParameters[\"words\"],\n                },\n                {\n                    value: seconds,\n                    word: \"seconds\" as keyof CountdownParameters[\"words\"],\n                },\n            ];\n            displayInline(timeUnits, parameters, inlineElement);\n        } else if (countdown) {\n            const timeUnits: TimeUnit[] = [\n                { value: days, word: \"days\" as keyof CountdownParameters[\"words\"] },\n                {\n                    value: hours,\n                    word: \"hours\" as keyof CountdownParameters[\"words\"],\n                },\n                {\n                    value: minutes,\n                    word: \"minutes\" as keyof CountdownParameters[\"words\"],\n                },\n                {\n                    value: seconds,\n                    word: \"seconds\" as keyof CountdownParameters[\"words\"],\n                },\n            ];\n            displayBlocks(timeUnits, parameters, countdown);\n        }\n    };\n\n    const startInterval = () => {\n        state.interval = setInterval(refresh, parameters.refresh);\n        refresh();\n    };\n\n    const stopCountdown = () => {\n        if (state.interval !== null) {\n            clearInterval(state.interval);\n            state.interval = null;\n        }\n        state.isPaused = true;\n        parameters.onStop?.();\n    };\n\n    const resumeCountdown = () => {\n        if (state.isPaused) {\n            startInterval();\n            state.isPaused = false;\n            parameters.onResume?.();\n        }\n    };\n\n    const updateCountdown = (newParams: Partial<CountdownParameters>) => {\n        Object.assign(parameters, newParams);\n        if (\n            newParams.year !== undefined ||\n            newParams.month !== undefined ||\n            newParams.day !== undefined ||\n            newParams.hours !== undefined ||\n            newParams.minutes !== undefined ||\n            newParams.seconds !== undefined\n        ) {\n            state.targetDate = getTargetDate(parameters);\n        }\n\n        parameters.onUpdate?.(newParams);\n\n        if (!state.isPaused) {\n            if (state.interval) {\n                clearInterval(state.interval);\n            }\n            startInterval();\n        }\n    };\n\n    const getState = () => ({ ...state });\n\n    // Start the countdown\n    startInterval();\n\n    // Cleanup on element removal\n    const observer = new MutationObserver((mutations) => {\n        mutations.forEach((mutation) => {\n            mutation.removedNodes.forEach((node) => {\n                if (node === targetElement) {\n                    if (state.interval !== null) {\n                        clearInterval(state.interval);\n                    }\n                    observer.disconnect();\n                }\n            });\n        });\n    });\n\n    if (targetElement.parentNode) {\n        observer.observe(targetElement.parentNode, { childList: true });\n    }\n\n    // Return controller object\n    return {\n        stopCountdown,\n        resumeCountdown,\n        updateCountdown,\n        getState,\n    };\n};\n\n/**\n * Creates an enhanced array of countdown controllers with additional control methods.\n *\n * @param controllers - Array of individual countdown controllers to be combined\n * @returns An array of controllers enhanced with collective control methods:\n *  - `stopCountdown()`: Stops all countdowns in the array\n *  - `resumeCountdown()`: Resumes all countdowns in the array\n *  - `updateCountdown(newParams)`: Updates all countdowns with new parameters\n *  - `getState()`: Returns an array of states from all countdowns\n */\nconst createControllerArray = (controllers: CountdownController[]): CountdownControllerArray => {\n    const array = controllers as CountdownControllerArray;\n\n    array.stopCountdown = () => controllers.forEach((c) => c.stopCountdown());\n    array.resumeCountdown = () => controllers.forEach((c) => c.resumeCountdown());\n    array.updateCountdown = (newParams) => controllers.forEach((c) => c.updateCountdown(newParams));\n    array.getState = () => controllers.map((c) => c.getState());\n\n    return array;\n};\n\n/**\n * Creates a countdown timer on specified HTML elements\n * @param element - A CSS selector string, HTMLElement, or NodeList targeting the countdown container(s)\n * @param args - Optional configuration parameters for the countdown\n * @returns A CountdownController for single element or CountdownControllerArray for multiple elements\n */\nconst simplyCountdown = (\n    element: CountdownSelector,\n    args: Partial<CountdownParameters> = defaultParams\n): CountdownController | CountdownControllerArray => {\n    const parameters: CountdownParameters = { ...defaultParams, ...args };\n\n    if (typeof element === \"string\") {\n        const elements = document.querySelectorAll<HTMLElement>(element);\n        const controllers = Array.from(elements).map((el) => createCountdownInstance(el, parameters));\n        return controllers.length === 1 ? controllers[0] : createControllerArray(controllers);\n    }\n\n    if (isNodeList(element)) {\n        const controllers = Array.from(element).map((el) => createCountdownInstance(el, parameters));\n        return controllers.length === 1 ? controllers[0] : createControllerArray(controllers);\n    }\n\n    return createCountdownInstance(element, parameters);\n};\n\nexport default simplyCountdown;\n"],"names":["createCountdownSection","sectionClass","amountClass","wordClass","amount","word","params","section","wrap","amount_elem","word_elem","updateCountdownSection","amountElement","wordElement","createCountdown","container","amountCls","wordCls","days","hours","minutes","seconds","defaultParams","root","n","isNodeList","element","formatTimeUnit","unit","shouldDisplay","previousUnits","u","displayInline","timeUnits","displayStr","index","displayBlocks","countdown","createCountdownInstance","targetElement","parameters","state","getTargetDate","inlineElement","refresh","currentDate","diff","startInterval","stopCountdown","_a","resumeCountdown","updateCountdown","newParams","getState","observer","mutations","mutation","node","createControllerArray","controllers","array","c","simplyCountdown","args","elements","el"],"mappings":"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"}